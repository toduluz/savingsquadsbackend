package data

import (
	"context"
	"errors"
	"log"
	"time"

	"github.com/toduluz/savingsquadsbackend/internal/validator"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"golang.org/x/crypto/bcrypt"
)

var (
	ErrDuplicateEmail = errors.New("duplicate email")
)

var AnonymousUser = &User{}

// User type whose fields describe a user. Note, that we use the json:"-" struct tag to prevent
// the Password and Version fields from appearing in any output when we encode it to JSON.
// Also, notice that the Password field uses the custom password type defined below.
type User struct {
	ID        primitive.ObjectID `json:"id" bson:"_id"`
	CreatedAt time.Time          `json:"-" bson:"created_at"`
	UpdatedAt time.Time          `json:"-" bson:"updated_at"`
	Name      string             `json:"name" bson:"name"`
	Email     string             `json:"email" bson:"email"`
	Password  password           `json:"-" bson:"password_hash"`
	Addresses []Address          `json:"addresses" bson:"addresses"`
	Phone     int                `json:"phone" bson:"phone"`
	Activated bool               `json:"activated" bson:"activated"`
	Vouchers  []Voucher          `json:"vouchers" bson:"vouchers"`
	Points    int                `json:"points" bson:"points"`
	Version   int                `json:"version" bson:"version"`
}

func (u *User) IsAnonymous() bool {
	return u == AnonymousUser
}

// UserModel struct wraps a sql.DB connection pool and allows us to work with the User struct type
// and the users table in our database.
type UserModel struct {
	DB       *mongo.Database
	InfoLog  *log.Logger
	ErrorLog *log.Logger
}

// password tyep is a struct containing the plaintext and hashed version of a password for a User.
// The plaintext field is a *pointer* to a string, so that we're able to distinguish between a
// plaintext password not being present in the struct at all, versus a plaintext password which
// is the empty string "".
type password struct {
	plaintext *string
	hash      []byte
}

type Address struct {
	Street     string `json:"street" bson:"street"`
	Number     string `json:"number" bson:"number"`
	PostalCode int    `json:"postal_code" bson:"postal_code"`
	City       string `json:"city" bson:"city"`
}

// Set calculates the bcrypt hash of a plaintext password, and stores both the has and the
// plaintext versions in the password struct.
func (p *password) Set(plaintextPassword string) error {
	hash, err := bcrypt.GenerateFromPassword([]byte(plaintextPassword), 12)
	if err != nil {
		return err
	}

	p.plaintext = &plaintextPassword
	p.hash = hash
	return nil
}

// Matches checks whether the provided plaintext password matches the hashed password stored in
// the password struct, returning true if it matches and false otherwise.
func (p *password) Matches(plaintextPassword string) (bool, error) {
	err := bcrypt.CompareHashAndPassword(p.hash, []byte(plaintextPassword))
	if err != nil {
		switch {
		case errors.Is(err, bcrypt.ErrMismatchedHashAndPassword):
			return false, nil
		default:
			return false, err
		}
	}

	return true, nil
}

// Insert inserts a new record in the users table in our database for the user. Note, that the id,
// created_at, and version fields are all automatically generated by our database, so we use use
// the RETURNING clause to read them into the User struct after the insert. Also, we check
// if our table already contains the same email address and if so return ErrDuplicateEmail error.
func (m UserModel) Insert(user *User) error {
	// Create a context with a 3-second timeout.
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	// Create a unique index on the email field if it doesn't exist.
	opts := options.CreateIndexes().SetMaxTime(3 * time.Second)
	keys := bson.D{{Key: "email", Value: 1}} // 1 for ascending order
	indexModel := mongo.IndexModel{Keys: keys, Options: options.Index().SetUnique(true)}
	_, err := m.DB.Collection("users").Indexes().CreateOne(ctx, indexModel, opts)
	if err != nil {
		return err
	}

	// Insert the user data into the users table.
	_, err = m.DB.Collection("users").InsertOne(ctx, user)
	if err != nil {
		// Check if it's a duplicate key error (which means the email already exists).
		if writeException, ok := err.(mongo.WriteException); ok {
			for _, writeError := range writeException.WriteErrors {
				if writeError.Code == 11000 {
					return ErrDuplicateEmail
				}
			}
		}
		return err
	}

	return nil
}

// GetByEmail retrieves the User details from the database based on the user's email address.
// Because we have a UNIQUE constraint on the email column, this query will only return one record,
// or none at all, upon which we return a ErrRecordNotFound error).
func (m UserModel) GetByEmail(email string) (*User, error) {
	// Create a context with a 3-second timeout.
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	// Define a User struct to hold the data returned by the query.
	var user User

	// Define the filter to match documents where email is email.
	filter := bson.M{"email": email}

	// Execute the find operation
	err := m.DB.Collection("users").FindOne(ctx, filter).Decode(&user)
	if err != nil {
		// If the error is a NoDocument error, return ErrRecordNotFound
		switch {
		case err == mongo.ErrNoDocuments:
			return nil, ErrRecordNotFound
		default:
			// Otherwise, return the error
			return nil, err
		}
	}

	return &user, nil
}

// Update updates the details for a specific user in the users table. Note, we check against the
// version field to help prevent any race conditions during the request cycle. Also, we check
// for a violation of the "user_email_key" constraint.
func (m UserModel) Update(user *User) error {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()
	// Define the filter to retrieve the document for the user with the specified id.
	filter := bson.M{"_id": user.ID}

	// Fetch the current state of the user.
	var currentUser User
	err := m.DB.Collection("users").FindOne(ctx, filter).Decode(&currentUser)
	if err != nil {
		return err
	}

	// Define the update document to set the new values of the fields.
	update := bson.M{
		"$set": bson.M{
			"name":       user.Name,
			"email":      user.Email,
			"activated":  user.Activated,
			"vouchers":   user.Vouchers,
			"points":     user.Points,
			"updated_at": time.Now(),
		},
	}

	isChangePassword, err := currentUser.Password.Matches(*user.Password.plaintext)
	if err != nil {
		return err
	}

	// Check if the email, password, activated, or role has changed.
	if isChangePassword || user.Activated != currentUser.Activated {
		update["$inc"] = bson.M{"version": 1} // increment the version
	}

	// Execute the update operation.
	_, err = m.DB.Collection("users").UpdateOne(ctx, filter, update)
	if err != nil {
		// Check if it's a duplicate key error (which means the email already exists).
		if writeException, ok := err.(mongo.WriteException); ok {
			for _, writeError := range writeException.WriteErrors {
				if writeError.Code == 11000 {
					return ErrDuplicateEmail
				}
			}
		}
		return err
	}

	return nil
}

// ValidateEmail checks that the Email field is not an empty string and that it matches the regex
// for email addresses, validator.EmailRX.
func ValidateEmail(v *validator.Validator, email string) {
	v.Check(email != "", "email", "must be provided")
	v.Check(validator.Matches(email, validator.EmailRX), "email", "must be valid email address")
}

// ValidatePasswordPlaintext validtes that the password is not an empty string and is between 8 and
// 72 bytes long.
func ValidatePasswordPlaintext(v *validator.Validator, password string) {
	v.Check(password != "", "password", "must be provided")
	v.Check(len(password) >= 8, "password", "must be at least 8 bytes long")
	v.Check(len(password) <= 72, "password", "must not be more than 72 bytes long")
}

func ValidateUser(v *validator.Validator, user *User) {
	// validate user.Name
	v.Check(user.Name != "", "name", "must be provided")
	v.Check(len(user.Name) <= 500, "name", "must not be more than 500 bytes long")

	// Validate email
	ValidateEmail(v, user.Email)

	// If the plaintext password is not nil, call the standalone ValidatePasswordPlaintext helper.
	if user.Password.plaintext != nil {
		ValidatePasswordPlaintext(v, *user.Password.plaintext)
	}

	// If the password has is ever nil, this will be due to a logic error in our codebase
	// (probably because we forgot to set a password for the user). It's a useful sanity check to
	// include here, but it's not a problem with the data provided by the client. So, rather
	// than adding an error to the validation map we raise a panic instead.
	if user.Password.hash == nil {
		panic("missing password hash for user")
	}
}
